AngularJS 的生命周期: 
	应用启动后会进行编译和链接，作用域会同HTML进行绑定，应用可以对用户在HTML中进行的操作进行实时响应。

	编译阶段 : 
		在编译阶段，AngularJS会遍历整个HTML文档并根据JavaScript中的指令定义来处理页面上声明的指令。

		每一个指令的模板中都可能含有另外一个指令，另外一个指令也可能会有自己的模板。嵌套使用。所以当AngularJS调用HTML文档根部的指令时，会遍历其中所有的模板，模板中也可能包含带有模板的指令。

		! : 模板树可能又大又深，但有一点需要注意，尽管元素可以被多个指令所支持或
			修饰，这些指令本身的模板中也可以包含其他指令，但只有属于最高优先级指
			令的模板会被解析并添加到模板树中。

			这里有一个建议，就是将包含模板的指令和添加行为的指令分离开来。如果一个
			元素已经有一个含有模板的指令了，永远不要对其用另一个指令进行修饰。也就是说，
			不要用这个指令去修改别的指令,只有具有最高优先级的指令中的模板会被编译。

		一旦对指令和其中的子模板进行遍历或编译，编译后的模板会返回一个叫做模板函数的函
		数。我们有机会在指令的模板函数被返回前，对编译后的DOM树进行修改。
		在这个时间点DOM树还没有进行数据绑定，意味着如果此时对DOM树进行操作只会有很少
		的性能开销。基于此点，ng-repeat和ng-transclude等内置指令会在这个时候，也就是还未与
		任何作用域数据进行绑定时对DOM进行操作。

		以ng-repeat为例，它会遍历指定的数组或对象，在数据绑定之前构建出对应的DOM结构。
		如果我们用ng-repeat来创建无序列表，其中的每一个<li>都会被ng-click指令所修饰，这
		个过程会使得性能比手动创建列表要快得多，尤其是列表中含有上百个元素时。
		与克隆<li>元素，再将其与数据进行链接，然后对每个元素都循环进行此操作的过程不同，
		我们仅需要先将无需列表构造出来，然后将新的DOM（编译后的DOM）传递给指令生命周期中
		的下一个阶段，即链接阶段。

		一个指令的表现一旦编译完成，马上就可以通过编译函数对其进行访问，编译函数的签名包
		含有访问指令声明所在的元素（tElemente）及该元素其他属性（tAttrs）的方法。这个编译函
		数返回前面提到的模板函数，其中含有完整的解析树。
		这里的重点是，由于每个指令都可以有自己的模板和编译函数，每个模板返回的也都是自己
		的模板函数。链条顶部的指令会将内部子指令的模板合并在一起成为一个模板函数并返回，但在
		树的内部，只能通过模板函数访问其所处的分支。
		最后，模板函数被传递给编译后的DOM树中每个指令定义规则中指定的链接函数，

作用域:--------------------------通过原型继承，树型结构。使用指令可以创建孤立的作用域。通过这个继承链进行广播事件。子可以访问父节点。本身是一个数据模型。不处理及操作数据，介于view和html之间。是view和ctrl的胶水。类似一个view的上下文。
	

	作用域提供了监视数据模型变化的能力。它允许开发者使用其中的apply机制，将数据模型的变化在整个应用范围内进行通知。我们在作用域的上下文中定义和执行表达式，同时它也是将事件通知给另一个控制器和应用其他部分的中介。

	将应用的业务逻辑都放在控制器中，而将相关的数据都放在控制器的作用域中，这是非常完美的架构。

	AngularJS启动并生成视图时，会将根ng-app元素同$rootScope进行绑定。$rootScope是所有$scope对象的最上层。

	$rootScope是AngularJS中最接近全局作用域的对象。在$rootScope上附加太多业务逻并不是好主意，这与污染JavaScript的全局作用域是一样的

	$scope对象在AngularJS中充当数据模型，但与传统的数据模型不一样，$scope并不负责处理和操作数据，它只是视图和HTML之间的桥梁，它是视图和控制器之间的胶水。

	作用域有以下的基本功能：
	 提供观察者以监视数据模型的变化；
	 可以将数据模型的变化通知给整个应用，甚至是系统外的组件；
	 可以进行嵌套，隔离业务功能和数据；
	 给表达式提供运算时所需的执行环境。

	ng-controller指令为这个DOM元素创建了一个新的$scope对象，并将它嵌套在$rootScope中。

	每当事件被处理时，$scope就会对定义的表达式求值。此时事件循环会启动，并且Angular应用会监控应用程序内的所有对象，脏值检测循环也会运行。

	$watch函数，Angular通过这些函数获知何时启动事件循环

	$scope对象的生命周期处理有四个不同阶段:
		创建(不只是controller会自动创建$scope。其它有些指令也可以创建作用域，并绑定到对应的dom中。)
			在创建控制器或指令时，AngularJS会用$injector创建一个新的作用域，并在这个新建的控制器或指令运行时将作用域传递进去。
		链接
			当Angular开始运行时，所有的$scope对象都会附加或者链接到视图中。所有创建$scope对象的函数也会将自身附加到视图中。这些作用域将会注册当Angular应用上下文中发生变化时需要运行的函数。这些函数被称为$watch函数，Angular通过这些函数获知何时启动事件循环。
		更新
			当事件循环运行时，它通常执行在顶层$scope对象上（被称作$rootScope），每个子作用域都执行自己的脏值检测。每个监控函数都会检查变化。如果检测到任意变化，$scope对象就会触发指定的回调函数。
		销毁
			当一个$scope在视图中不再需要时，这个作用域将会清理和销毁自己。尽管永远不会需要清理作用域（因为Angular会为你处理），但是知道是谁创建了这个作用域还是有用的，因为你可以使用这个$scope上叫做$destory()的方法来清理这个作用域。

	! : 出于技术和架构方面的原因，绝对不要直接将控制器中的$scope赋值为值类型对象（字符串、布尔值或数字）。DOM中应该始终通过点		操作符.来访问数据。遵守这个规则将使你远离不可预期的麻烦。

	ng-model : 双向绑定,没有model时，自动创建model。


	派生$scope指令:
   ng-include : 使用ng-include可以加载、编译并包含外部HTML片段到当前的应用中,自动创建一个子作用域,除了在同一个DOM元素上添加ng-				controller指名。
 ng-switch
 ng-repeat ： ng-repeat用来遍历一个集合或为集合中的每个元素生成一个模板实例。集合中的每个元素都会被赋予自己的模板和作用域。				 同时每个模板实例的作用域中都会暴露一些特殊的属性：
				 $index：遍历的进度（0...length-1）。
				 $first：当元素是遍历的第一个时值为true。
				 $middle：当元素处于第一个和最后元素之间时值为true。
				 $last：当元素是遍历的最后一个时值为true。
				 $even：当$index值是偶数时值为true。
				 $odd：当$index值是奇数时值为true。
 ng-view
 ng-controller
 ng-if ： 当一个元素被ngif从DOM中移除，同它关联的作用域也会被销毁。而且当它重新加入DOM中时，会通过原型继承从它的父作用域生成			  一个新的作用域

控制器:-------------------------------不处理数据及dom操作，只处理存储数据，只是View和$scope的中介。ViewModel。
	控制器在AngularJS中的作用是增强视图。在Hello World的例子中，我们并没有使用普通的控制器，而是使用了一个隐式控制器。
	AngularJS中的控制器是一个构造函数，用来向视图的作用域中添加额外的功能。我们用它来给作用域对象设置初始状态，并添加自定义行为
	
	当我们在页面上创建一个新的控制器时，AngularJS会生成并传递一个新的$scope给这个控制器。可以在这个控制器里初始化$scope。由于AngularJS会负责处理控制器的实例化过程，我们只需编写构造函数即可。

	正如我们看到的那样，AngularJS会在创建作用域时调用控制器方法。

	控制器可以将与一个独立视图相关的业务逻辑封装在一个独立的容器中。尽可能地精简控制器是很好的做法。作为AngularJS开发者，使用依赖注入来访问服务可以实现这个目的。控制器应该尽可能保持短小精悍，而在控制器中进行DOM操作和数据操作则是一个不好的实践。


	AngularJS同其他JavaScript框架最主要的一个区别就是，控制器并不适合用来执行DOM操作、格式化或数据操作，以及除存储数据模型之外的状态维护操作。它只是视图和$scope之间的桥梁。?
	
	AngularJS通过作用域将视图、控制器和指令（本书后面会介绍）隔离开来，这样就很容易为功能的具体部分编写测试。

	! : 控制器应该尽可能简单。虽然可以用控制器来组织所有功能，但是将业务逻辑移到服务和指令中是非常好的主意。或分离到service，	 依赖注入。

	例:
	angular.module('myApp', [])
	.controller('MyController', function($scope) {
	$scope.shouldShowLogin = true;
	$scope.showLogin = function () {
	$scope.shouldShowLogin = !$scope.shouldShowLogin;
	};
	$scope.clickButton = function() {
	$('#btn span').html('Clicked');
	};
	$scope.onLogin = function(user) {
	$http({
	method: 'POST',
	url: '/login',
	data: {
	user: user
	}
	}).success(function(data) {
	// user
	});
	};
	});

	to:

	angular.module('myApp', [])
	.controller('MyController', function($scope,UserSrv) {
	// 内容可以被指令控制
	$scope.onLogin = function(user) {
	UserSrv.runLogin(user);
	};
	});


表达式:-------------------------------------------------------
	对表达式进行的任何操作，都会在其所属的作用域内部执行，因此可以在表达式内部调用那些限制在此作用域内的变量，并进行循环、函数调用、将变量应用到数学表达式中等操作。

	可以view上面通过input输入它获取scope上的属性及值:
		将$parse服务注入到控制器中，然后调用它就可以实现手动解析表达式(可以通过它获取scope上的属性)

		$interpolate : 现在，在{{ previewText }}内部的文本中可以将{{ to }}当做一个变量来使用，并对文本的变化进行实时更新。用户输入的文本中可以使用表格式。访问并计算scope里面的值。
		如果需要在文本中使用不同于{{ }}的符号来标识表达式的开始和结束，可以在$inter polateProvider中配置。

过滤器:-------------------------------------------------------
		调用方式
		html:
			1.{{ }}内通过|符号来调用过滤器:{{ name | uppercase }},
			2.以HTML的形式使用过滤器时，如果需要传递参数给过滤器，只要在过滤器名字后面加冒号
				即可。如果有多个参数，可以在每个参数后面都加入冒号。{{ 123.456789 | number:2 }}
			3.自定义函数:{{ ['Ari','likes','to','travel'] | filter:isCapitalized }}
		js:	$scope.name = $filter('lowercase')('Ari');


表单验证:--------------------------------------------------
	通过指令方式
	$parsers : 链式检查，验证值是否有效。$parsers数组中的函数会以流水线的形式被逐个调用。第一个$parse被调用后，执行结果会传
				递给第二个$parse，以此类推。这些函数可以对输入值进行转换，或者通过$setValidity()函数设置表单的合法性。使用$parsers数组是实现自定义验证的途径之一。例如，假设我们想要确保输入值在某两个数值之间，可以在$parsers数组中入栈一个新的函数，这个函数会在验证链中被调用。每个$parser返回的值都会被传入下一个$parser中。当不希望数据模型发生更新时返回undefined。
	$formatters : 改变表单值。:当绑定的ngModel值发生了变化，并经过$parsers数组中解析器的处理后，这个值会被传递给$formatters流			水线;同$parsers数组可以修改表单的合法性状态类似，$formatters中的函数也可以修改并格式化这些值。

	ngMessages(模块)$error

	Css : .ng-pristine {}.ng-dirty {}.ng-valid {}.ng-invalid {}

			ngModel是一个用法特殊的指令，它提供更底层的API来处理控制器内的数据。当我们在指令
		中使用ngModel时能够访问一个特殊的API，这个API用来处理数据绑定、验证、CSS更新等不实
		际操作DOM的事情。
		ngModel控制器会随ngModel被一直注入到指令中，其中包含了一些方法。为了访问
		ngModelController必须使用require设置（像前面的例子中那样）：

		angular.module('myApp')
		.directive('myDirective',function(){
			return {
				require: '?ngModel',
				link: function(scope, ele, attrs, ngModel) {
					if (!ngModel) return;
					// 现在我们的指令中已经有ngModelController的一个实例
				}
			};
		});

		!: 这个指令没有隔离作用域。如果给这个指令设置隔离作用域，将导致内部ngModel无
		法更新外部ngModel的对应值：AngularJS会在本地作用域以外查询值。
		为了设置作用域中的视图值，需要调用ngModel.$setViewValue()函数。ngModel.$set
		ViewValue()函数可以接受一个参数。
		value（字符串）：value参数是我们想要赋值给ngModel实例的实际值。这个方法会更新控
		制器上本地的$viewValue，然后将值传递给每一个$parser函数（包括验证器）。
		当值被解析，且$parser流水线中所有的函数都调用完成后，值会被赋给$modelValue属性，
		并且传递给指令中ng-model属性提供的表达式。
		最后，所有步骤都完成后，$viewChangeListeners中所有的监听器都会被调用。
		注意，单独调用$setViewValue()不会唤起一个新的digest循环，因此如果想更新指令，需要
		在设置$viewValue后手动触发digest。
		$setViewValue()方法适合于在自定义指令中监听自定义事件（比如使用具有回调函数的
		jQuery插件），我们会希望在回调时设置$viewValue并执行digest循环。
		angular.module('myApp')
		.directive('myDirective', function() {
			return {
				require: '?ngModel',
				link: function(scope, ele, attrs, ngModel) {
					if (!ngModel) return;
					$(function() {
						ele.datepicker({
							onSelect: function(date) {
							// 设置视图和调用apply
								scope.$apply(function() {
									ngModel.$setViewValue(date);
								});
							}
						});
					});
				}
			};
		});



		属性 : 

		ngModelController中有几个属性可以用来检查甚至修改视图。
		1. $viewValue
		$viewValue属性保存着更新视图所需的实际字符串。
		2. $modelValue
		$modelValue由数据模型持有。$modelValue和$viewValue可能是不同的，取决于$parser
		流水线是否对其进行了操作。
		3. $parsers
		$parsers的值是一个由函数组成的数组，其中的函数会以流水线的形式被逐一调用。
		ngModel从DOM中读取的值会被传入$parsers中的函数，并依次被其中的解析器处理。
		这是为了对值进行处理和修饰。我们已经简单介绍过验证流水线是如何工作的了。更多关于
		通过创建$parser来进行验证的信息请查阅10.6节。
		4. $formatters
		$formatters的值是一个由函数组成的数组，其中的函数会以流水线的形式在数据模型的值
		发生变化时被逐一调用。它和$parser流水线互不影响，用来对值进行格式化和转换，以便在绑
		定了这个值的控件中显示。
		5. $viewChangeListeners
		$viewChangeListeners的值是一个由函数组成的数组，其中的函数会以流水线的形式在视
		图中的值发生变化时被逐一调用。通过$viewChangeListeners，可以在无需使用$watch的情况
		下实现类似的行为。由于返回值会被忽略，因此这些函数不需要返回值。
		图灵社区会员 鸟月月(dearzpfree@hotmail.com) 专享 尊重版权
		6. $error
		$error对象中保存着没有通过验证的验证器名称以及对应的错误信息。
		7. $pristine
		$pristine的值是布尔型的，可以告诉我们用户是否对控件进行了修改。
		8. $dirty
		$dirty的值和$pristine相反，可以告诉我们用户是否和控件进行过交互。
		9. $valid
		$valid值可以告诉我们当前的控件中是否有错误。当有错误时值为false，没有错误时值为true。
		10. $invalid
		$invalid值可以告诉我们当前控件中是否存在至少一个错误，它的值和$valid相反。

指令:-------------------------------------------------------
	简单的理解成在特定DOM元素上运行的函数，指令可以扩展这个元素的功能

	$compile服务利用这个方法返回的对象，在DOM调用指令时来构造指令的行为

	通过对象来定义是最佳的方式。当返回一个函数时，这个函数通常被称作链接传递（postLink）函数，利用它我们可以定义指令的链接（link）功能。由于返回函数而不是对象会限制定义指令时的自由度，因此只在构造简单的指令时才比较有用。

	当AngularJS在DOM中遇到具名的指令时，会去匹配已经注册过的指令，并通过名字在注册过的对象中查找。此时，就开始了一个指令的生命周期，指令的生命周期开始于$compile方法并结束于link方法

	绑定策略:
						将指令内部的隔离作用域，同指令外部的作用域进行数据绑定

						1 : 本地作用域属性 : @ or @attr 使用@符号将本地作用域同DOM属性的值进行绑定。指令内部作用域可以
							使用外部作用域的变量
						2 : 双向绑定 : = (or =attr)将本地作用域上的属性同父级作用域上的属性进行双向的数据绑定。就像普通的数据绑定一样，本地			属性会反映出父数据模型中所发生的改变

						3 : 父级作用域绑定 : & (or &attr)通过&符号可以对父级作用域进行绑定，以便在其中运行函数。意味着对这
							个值进行设置时会生成一个指向父级作用域的包装函,要使调用带有一个参数的父方法，我们需要传递一个对象，这个对象的键是参数的名称，值是要传递给参数的内容。

						<input type="text" ng-model="to"/>
						<!-- 调用指令 -->
						<div scope-example ng-model="to"
							on-send="sendMail(email)"
							from-name="ari@fullstack.io" />

						这里有一个数据模型（ng-model），一个函数（sendMail()）和一个字符串（from-name）。
						在指令中做如下设置以访问这些内容：
							scope: {
								ngModel: '=', // 将ngModel同指定对象绑定
								onSend: '&', // 将引用传递给这个方法
								fromName: '@' // 储存与fromName相关联的字符串
							}


	angular.module('myApp', [])
	.directive('myDirective', function() {
			return {
				restrict: String,  //DOM匹配或声明方式 E（元素）A（属性，默认值）C（类名）M（注释:不要使用）
				
				priority: Number,  //运行顺序;default 0
				
				terminal: Boolean, //AngularJS停止运行当前元素上比本指令优先级低的指令,终止顺序
				
				template: String(必须存在一个根DOM元素) or Template Function: function(tElement, tAttrs//t代表template，是相对			于instance的。在讨论链接和编译设置时会详细介绍，模板元素或属性与实例元素或属性之间的区别) (...},
				templateUrl: 同template一样,  模板的URL都将通过AngularJS内置的安全层，特别是$getTrustedResourceUrl，这样可以保护    模板不会被不信任的源加载。模板加载是异步的，意味着编译和链接要暂停，等待模板加载完成。为了避免延迟，可以在部 署应用之前对HTML模板进行缓存。模板加载后，AngularJS会将它默认缓存到$templateCache服务中。在实际生产中，可以提前将模板缓存到一个定义模板的JavaScript文件中，这样就不需要通过XHR来加载模板了。

				replace: Boolean or String,
				
				scope: Boolean or Object,
					作用域(和dom绑定):
						DOM中每个指令调用时都可能会：
						 直接调用相同的作用域对象；
						 从当前作用域对象继承一个新的作用域对象；
						 创建一个同当前作用域相隔离的作用域对象
						! : 指令嵌套并不一定意味着需要改变它的作用域。默认情况下，子指令会被付予访问父DOM元素对应的作用域的能力，这样做的原因	可以通过介绍指令的scope参数来理解，scope参数默认是false。
						
						scope参数 : 
							默认值是false，也可以为一个对象或true。为true会从父作用域继承并创建一个新的作用域对象
							
							如果一个元素上有多个指令使用了隔离作用域(指令自己独立的scope。没有继承)，其中只有一个可以生效。只有指令模板中的
							根元素可以获得一个新的作用域。因此，对于这些对象来说scope默认被设置为true，这样都可以访问相同作用域。内置指令ng-controller的作用，就是从父级作用域继承并创建一个新的子作用域。它会创建一个新的从父作用域继承而来的子作用域

						隔离作用域:
							最主要的使用场景是创建可复用的组件，组件可以在未知上下文中使用，并且可以避免污染所处的外部作用域或不经意地污染内部作用域，因为它是独立的，不会继承。
				transclude: Boolean,
					嵌入通常用来创建可复用的组件，典型的例子是模态对话框或导航栏。我们可以将整个模板，包括其中的指令通过嵌入全部传入一个指令中。这样做可以将任意内容和作用域传递给指令。指令的内部可以访问外部指令的作用域，并且模板也可以访问外部的作用域对象。
					
					! : 1 . 为了将作用域传递进去，scope参数的值必须通过{}或true设置成隔离作用域。如果没有设置scope参数，那么指		  令内部的作用域将被设置为传入模板的作用域。

						2 . 只有当你希望创建一个可以包含任意内容的指令时，才使用transclude: true。

						3 . 如果指令使用了transclude参数，那么在控制器（下面马上会介绍）中就无法正常监听数据模型的变化了。这就	  是最佳实践总是建议在链接函数里使用$watch服务的原因。

					example : 我们来创建一个可以复用的侧边栏，同WordPress博客的侧边栏很相似
						<div sidebox title="Links">
				            <ul>
				                <li>First link</li>
				                <li>Second link</li>
				            </ul>
			            </div>
			            // div里面的节点相当于ng-transclude。直接替换的。

			            .directive('sidebox', function() {
						return {
								restrict: 'EA',
								scope: {
								title: '@'
								},
								transclude: true,
								template: '<div class="sidebox">\
								                <div class="content">\
								                    <h2 class="header">{{ title }}</h2>\
								                    <span class="content" ng-transclude>\
								                    </span>\
								                </div>\
								            </div>'
							};
						});

				controller: String or function($scope(与指令元素相关联的当前作用域), $element(当前指令对应的元素), $attrs(由当前元素的属性组成的对象), $transclude(嵌入链接函数会与对应的嵌入作用域进行预绑定,属性上的函数,transclude链接函数是实际被执行用来克隆元素和操作DOM的函数), otherInjectables) { ... },
					controller参数可以是一个字符串或一个函数。当设置为字符串时，会以字符串的值为名字，来查找注册在应用中的控制器的构造函数

					! : 在控制器内部操作DOM是和AngularJS风格相悖的做法，但通过链接函数就可以实现这个需求。仅在compile参数中使	 用transcludeFn是推荐的做法。
					example : 
						angular.module('myApp')
						.directive('link', function() {
						return {
							restrict: 'EA',
							transclude: true,
							controller:
							function($scope, $element, $transclude, $log) {
								$transclude(function(clone) {
								var a = angular.element('<a>');
								a.attr('href', clone.text());
								a.text(clone.text());
								$log.info("Created new a tag in link directive");
								$element.append(a);
							});
						}
						};
						});


					指令的控制器和link函数可以进行互换。控制器主要是用来提供可在指令间复用的行为，但链接函数只能在当前内部指令中定义行为，且无法在指令间复用。

					! : link函数可以将指令互相隔离开来，而controller则定义可复用的行为。由于指令可以require其他指令所使用的控	 制器，因此控制器常被用来放置在多个指令间共享的动作。如果我们希望将当前指令的API暴露给其他指令使用，可
					    以使用controller参数，否则可以使用link来构造当前指令元素的功能性。如果我们使用了scope.$watch()或者想要与DOM元素做实时的交互，使用链接会是更好的选择。

					! : 技术上讲，$scope会在DOM元素被实际渲染之前传入到控制器中。在某些情况下，例如使用了嵌入，控制器中的作用
					    域所反映的作用域可能与我们所期望的不一样，这种情况下，$scope对象无法保证可以被正常更新。

					    当想要同当前屏幕上的作用域交互时，可以使用被传入到link函数中的scope参数。

				controllerAs: String,
				require: String or String[],字符串或数组元素的值是会在当前指令的作用域中使用的指令名称，
						require会将控制器注入到其值所指定的指令中，并作为当前指令的链接函数的第四个参数。
						scope会影响指令作用域的指向，是一个隔离作用域，一个有依赖的作用域或者完全没有作用域。在任何情况下，AngularJS编译器在查找子控制器时都会参考当前指令的模板。

						<!-- 指令会在本地作用域查找ng-model -->
						<div my-directive ng-model="object"></div>

						//...
						restrict: 'EA',
						require: 'ngModel' //指令定义只会查找定义在指令作当前用域中的ng-model=""
						//...

						require参数的值可以用下面的前缀进行修饰，这会改变查找控制器时的行为：
							?
							如果在当前指令中没有找到所需要的控制器，会将null作为传给link函数的第四个参数。
							^
							如果添加了^前缀，指令会在上游的指令链中查找require参数所指定的控制器。
							?^
							将前面两个选项的行为组合起来，我们可选择地加载需要的指令并在父指令链中进行查找。
						没有前缀
							如果没有前缀，指令将会在自身所提供的控制器中进行查找，如果没有找到任何控制器（或
							具有指定名字的指令）就抛出一个错误。

						example :  检查名称唯一
							angular.module('validationExample', [])
							.directive('ensureUnique',function($http) {
							return {
									require: 'ngModel',
									link: function(scope, ele, attrs, c) {
										scope.$watch(attrs.ngModel, function() {
											$http({
												method: 'POST',
												url: '/api/check/' + attrs.ensureUnique,
												data: {field: attrs.ensureUnique, valud:scope.ngModel
												})
												.success(function(data,status,headers,cfg) {
													c.$setValidity('unique', data.isUnique);
												})
												.error(function(data,status,headers,cfg) {
													c.$setValidity('unique', false);
												});
										});
									}
								};
							});

				link: function(scope(指令用来在其内部注册监听器的作用域), 
								iElement(代表实例元素，指使用此指令的元素。在postLink函数中我们应该只操作此
							元素的子元素，因为子元素已经被链接过了。), 

							iAttrs(实例属性，是一个由定义在元素上的属性组成的标准化列表，可以在所有指
							令的链接函数间共享。会以JavaScript对象的形式进行传递。)
							) { ... },
						用link函数创建可以操作DOM的指令。
						link function负责注册DOM事件监听器，也可以进行DOM的更新操作。link function会在模版克隆操作完毕之后执行。这里存放着directive大多数的逻辑。

						只有在postLink function里面对子元素进行操作，才是安全的。因为子元素已经被link

						// require 'SomeController',
						link: function(scope, element, attrs, 
						SomeController(指向require选项定义的控制器)) {
						// 在这里操作DOM，可以访问required指定的控制器
						//控制器在所有的指令间共享，因此指令可以将控制器当作通信通道（公共API）。如果设置了
							多个require，那么这个参数会是一个由控制器实例组成的数组，而不只是一个单独的控制器。
						}

						如果require选项提供了一个指令数组，第四个参数会是一个由每个指令所对应的控制器组
						成的数组。
						允许各个directive将controller当作一个它们之间沟通频道。
							

						angular.module('myApp', [])
						.directive('myDirective', function() {
							return {
							link: function(scope, ele, attrs) {
								return {
									pre: function(tElement, tAttrs, transclude) {
										// 在子元素被链接之前执行
										// 在这里进行Don转换不安全
										// 之后调用'lihk'函数将无法定位要链接的元素
									},
									post: function(scope, iElement, iAttrs, controller) {
										// 在子元素被链接之后执行
										// 如果在这里省略掉编译选项
										//在这里执行DOM转换和链接函数一样安全吗
									}
								}
							}
						});

						link函数对绑定了实时数据的DOM具有控制能力，因此需要考虑性能问题

						! : 
							compile会覆盖link函数。
							编译函数负责对模板DOM进行转换。
							链接函数负责将作用域和DOM进行链接,在作用域同DOM链接之前可以手动操作DOM,很少使用。

				compile: // 返回一个对象或连接函数，如下所示:
					function(tElement, tAttrs, transclude) {
						return {
						pre: function(scope, iElement, iAttrs, controller) { ... },
						post: function(scope, iElement, iAttrs, controller) { ... }
						}
						// 或者
						return function postLink(...) { ... }
					}
					compile function用于处理DOM模版的转换。由于大多数directive都不需要转换模版，所以compile不会经常被使用到。需要compile function的directive，一般是那种需要转换DOM模版的（如ngRepeat），或者是需要异步加载内容的（如ngView）

					compile选项可以返回一个对象或函数。
					
					理解compile和link选项是AngularJS中需要深入讨论的高级话题之一，对于了解AngularJS究竟是如何工作的至关重要。

					compile选项本身并不会被频繁使用，但是link函数则会被经常使用,本质上，当我们设置
					了link选项，实际上是创建了一个postLink()链接函数，以便compile()函数可以定义链接函数。

					作用:
						通常情况下，如果设置了compile函数，说明我们希望在指令和实时数据被放到DOM中之前
						进行DOM操作，在这个函数中进行诸如添加和删除节点等DOM操作是安全的。

						编译函数负责对模板DOM进行转换。
						链接函数负责将作用域和DOM进行链接


					! : compile和link选项是互斥的。如果同时设置了这两个选项，那么会把compile
						所返回的函数当作链接函数，而link选项本身则会被忽略。

	};



模块加载----------------------------------------------- : 

	config(配置):
		configFunction（函数）：AngularJS在模块加载时会执行这个函数，只有少数几种类型的对象可以被注入到config()函数
		中：提供者和常量。如果我们将一个服务注入进去，会在真正对其进行配置之前就意外地把服务实例化了。注入用provider()语法构
		建的服务，其他的则不行

		这个阶段是唯一能够在应用启动前进行修改的部分。
		根据声明顺序执行，所以无法注入一个没有注册的提供者,唯一例外的是constant()方法，这个方法总会在所有配置块之前被执行。
		大部分使用这个语法糖。
		angular.module('myApp', [])
		.config(function($provide ,$compileProvider) {
			$provide.factory('myFactory', function() {
				var service = {};
				return service;
			});
			$compileProvider.directive('myDirective', function() {
				return {
				template: '<button>Click me</button>'
				};
			});
		});

	run(运行块) : 
		initializeFn（函数）AngularJS在注入器创建后会执行这个函数。和配置块不同，运行块在注入器创建之后被执行。它是所有AngularJS应用中第一个被执行的方法，类似于main方法，常用来注册全局的事件监听器，如run中设置事件路由的监听器及非法请求过滤。

		每次路由发生变化时，都执行一个函数来验证用户的权限:
		angular.module('myApp', [])
		.run(function($rootScope, AuthService) {
			$rootScope.$on('$routeChangeStart', function(evt, next, current) {
				// 如果用户未登录
				if (!AuthService.userLoggedIn()) {
					if (next.templateUrl === "login.html") {
						// 已经转向登录路由因此无需重定向
					} else {
						$location.path('/login');
					}
				}
			});
		});

多重视图和路由:-----------------------------------------------------------------
	除了用ngInclude指令在视图中引用多个模板外，更好的做法是将视图分解成布局和模板视图，并且根据用户当前访问的URL来展示对应的视图。我们利用$route和$routeProvider将这些模板分解到视图中，并在布局模板内进行组装。以视图进行布局，将变化的内容用视图展示，通过路由实现浏览器的历史功能。

	angular的1.2 version就把route分离出来，需要在angular.js后引入route模块。

	布局模板:通过route模块提供的ngView指令，可以确定当前路由对应的模板在dom中的渲染位置。ngView给$route在dom中提供对应的占位。
	并继承scope创建自己的作用域并将模板嵌套的内部。

	ng-view 的优先级为1000(终极指令),它的规则如下:
		每次触发$routeChangeSuccess事件，视图都会更新。
		如果某个模板同当前的路由相关联:
			1.派生新的scope
			2.移除旧的scope和视图
			3.新的scope和模板关联
			4.路由中有相关的定义，就将派生scope传给控制器。
			5.触发$viewContentLoaded
		6.如果提供了onload，就调用


	路由设置:
		angular.module('myApp', [])
		.config(['$routeProvider', function($routeProvider) {
			$routeProvider.when(
			'/', //路由路径，与$location.path进行匹配，表示当前URL路径，参数:$routeParams ,$location对window.loaction封装了。		可以修改路径及处理导航。常用于内部跳转，如用户注册后、登录后的跳转。$location服务不会重新加载整个页面，它只		  会单纯地改变URL。如果我们想重新加载整个页面，需要用$window服务来设置地址
			{
				template : "",直接渲染
				templateUrl: 'views/home.html',XHR或$templateCache 获取模板
				controller: 'HomeController',函数及String，返回和查找控件器，并与ngView scope关联。
				resolve : {},会将列表的元素，见下面,注入到控制器里面。如果是这些依赖是promise对象，它们在控制器加载及
							$routeChangeSucces被触发之前被resolve设置成一个值。
							列表对象可以是：
							 1.键，键值是会被注入到控制器中的依赖的名字；
							 2.工厂，即可以是一个服务的名字，也可以是一个返回值，它是会被注入到控制器中的函数或可以
								被resolve的promise对象。

				redirectTo : "",string or function(route,path,search) 替换当前url
				reloadOnSearch : default true 在$location.search()
								发生变化时重载，反之。这个小窍门对路由嵌套和原地分页等需求非常有用
			});
		}]);

	路由事件 : 
		$route服务在路由过程中的每个阶段都会触发不同的事件，可以为这些不同的路由事件设置监听器并做出响应。
		事件:
			$routeChangeStart : 路由变化之前会广播在这一步中，路由服务会开始加载路由变化所需要的所有依赖，并且模板
								和resolve键中的promise也会被resolve。

			$routeChangeSuccess : 在路由的依赖被加载后广播

			$routeChangeError : 在任何一个promise被拒绝或者失败时广播

			$routeUpdate : 在reloadOnSearch属性被设置为false的情况下，重新使用某个控制器的实例时，会广播$routeUpdate事件。






依赖注入 : --------------------------------------------------------------------------
	在需要的地方通过参数进行传递。$injetor负责实例化AngularJS中所有的组件，包括应用的模块、指令和控制器等。
	在运行时，任何模块启动时$injetor都会负责实例化，并将其需要的所有依赖传递进去。

	angular.module('myApp', [])
	.factory('greeter', function() {
		return {
		greet: function(msg) {alert(msg);}
		}
	})
	.controller('MyController',
		function($scope, greeter) {
			$scope.sayHello = function() {
			greeter.greet("Hello!");
		};
	});

	内部原理:

	// 使用注入器加载应用
	var injector = angular.injector(['ng', 'myApp']);
	// 通过注入器加载$controller服务：var $controller = injector.get('$controller');
	var scope = injector.get('$rootScope').$new();
	// 加载控制器并传入一个作用域，同AngularJS在运行时做的一样
	var MyController = $controller('MyController', {$scope: scope})

	AngularJS通过annotate函数，在实例化时从传入的函数中把参数列表提取出来

	当编写控制器时，如果没有使用[]标记或进行显式的声明，$injector就会尝试通过参数名推断依赖关系。

	没有显示声明，调用 function toStrng方法，通过annotate获取依赖，不依赖参数顺序，但只适用于未经过压缩和混淆的代码。
	因为JavaScript的压缩器通常会将参数名改写成简单的字符，以减小源文件体积（同时也会删除空格、空行和注释等

	显式注入声明，使用数组方式，依赖声明顺序，支持压缩。

	$injector API:
		annotate(fn or array) : 方法的返回值是一个由服务名称组成的数组，这些服务会在实例化时被注入到目标函数中。annotate()							方法可以帮助$injector判断哪些服务会在函数被调用时注入进去。获取注入服务名称。
		get(str) : 获取服务。
		has(str) : 查找单个服务是否存在。

		instantiate(fn,locals) : 方法可以创建某个JavaScript类型的实例。它会通过new操作符调用构造函数，并将所有参数都传递给
									构造函数。它可以接受两个参数。
		invoke(tofn,objThis,locals) return tofn 会调用方法并从$injector中添加方法参数。


服务: ----------------------------------------------------------------------
	服务是一个单例对象,被$injector实例化一次。并且是延迟加载的（需要时才会被创建）
	服务提供了把与特定功能相关联的方法集中在一起的接口

	使用服务也是在控制器之间共享数据的典型方法。

	创建服务:
		factory(name,fn or arr fn) : 是创建和配置服务的最快捷、最常规方式
	 	service(name,constructor) : 注册一个支持构造函数的服务,它允许我们为服务对象注册一个构造函数。
									实例时通过new关键字来实例化服务对象
  		provider() : 所有服务工厂都是由$provide服务创建的，$provide服务负责在运行时初始化这些提供者。提供者是一个具有$get()				方法的对象，$injector通过调用$get方法创建服务实例。

  					从技术上说，当我们假定传入的函数就是$get()时，factory()函数就是用provider()方法
					注册服务的简略形式。
					下面两种方法的作用完全一样，并且会创建同一个服务。
					angular.module('myApp')
					.factory('myService', function() {
						return {
						'username': 'auser'
						};
					})
					// 这与上面工厂的用法等价
					.provider('myService', {
						$get: function() {
							return {
							'username': 'auser'
							};
						}
					});


					是否可以一直使用.factory()方法来代替.provider()呢？
					答案取决于是否需要用AngularJS的.config()函数来对.provider()方法返回的服务进行额
					外的扩展配置。同其他创建服务的方法不同，config()方法可以被注入特殊的参数。

					在上面的例子中，provider()方法在文本githubService后添加Provider生成了一个新的提
					供者，githubServiceProvider可以被注入到config()函数中。

					! : 如果希望在config()函数中可以对服务进行配置，必须用provider()来定义服务。

					所有创建服务的方法都构建在provider方法之上。provider()方法负责在$providerCache中注册服务。

					.provider()是非常强大的，可以让我们在 不同的应用中 共享服务

		constant() : 可以将一个已经存在的变量值注册为服务，并将其注入到应用的其他部分当中
					 angular.module('myApp') .constant('apiKey','123123123')//像服务一样使用。 
					 常量可以注入到配置函数中，而值不行
					 可以通过value()来注册服务对象或函数，用constant()来配置数据。
					 这个常量不能被装饰器拦截,decorator()拦截不到。

	 	value() : 如果服务的$get方法返回的是一个常量，就使用这个
						angular.module('myApp').value('apiKey','123123123');
						常量可以注入到配置函数中，而值不行
						可以通过value()来注册服务对象或函数，用constant()来配置数据。
	 	decorator() : 装饰器 : 服务实例创建时对其进行拦截的功能,用于扩展，或者用另外的内容完全代替它。

					场景有很多 : 比如对服务进行扩展，将外部数据缓存进localStorage的功能
								 对服务进行封装以便在开发中进行调试和跟踪

					 	name（字符串）
							将要拦截的服务名称。
						decoratorFn（函数）
							在服务实例化时调用该函数，这个函数由injector.invoke调用，可以将服务注入这个函数中。
							$delegate是可以进行装饰的最原始的服务，为了装饰其他服务，需要将其注入进装饰器。

					每个请求都加上一个时间戳 : 
								var githubDecorator = function($delegate,$log) {
									var events = function(path) {
										var startedAt = new Date();
										var events = $delegate.events(path);
										// 事件是一个promise 
										events.finally(function() {
											$log.info("Fetching events" +
												" took " +
												(new Date() - startedAt) + "ms");
										});
										return events;
										};
										return {
										events: events
										};
								};

								angular.module('myApp')
								.config(function($provide) {
									$provide.decorator('githubService',githubDecorator);
								});


XHR和服务器通信--------------------------------------------------------------
	$http:
		$http服务只是简单的封装了浏览器原生的XMLHttpRequest对象。
		
		在创建服务时会频繁使用链式调用技术，因此服务可以返回一个promise对象，而不需要回
		调函数。

		var promise = $http({
			method: 'GET',
			url: '/api/users.json'
		});

		由于$http方法返回一个HttpPromis对象:
			then : 会得到一个特殊的参数，它代表了相应对象的成功或失败信息，还可以接受两个可选的函数作为参数。区别于success和error的地方是它会接收到完整的响应对象，前面的两个方法会对响应对象进行析构。
			success :  如果响应状态码在200和299之间，会认为响应是成功的，success回调会被调用
			error :  否则error回调会被调用。重写向的不会进error。

		两个函数参数：
		promise.then(function(resp){
			// resp是一个响应对象:
			data :转换过后的响应内容，如果定义了转换。
			status : 状态码
			headers : 头信息的getter函数，可以接受一个参数，用来获取对应名字的值
			config : 对象是用来生成原始请求的完整设置对象。类似于构造http时的对象
			statusText : 是响应的HTTP状态文本。

		}, function(resp) {
		// 带有错误信息的resp
		});

		用success和error代替 : then :
		// 或者使用success/error方法
		promise.success(function(data, status, headers, config){
		// 处理成功的响应
		});
		// 错误处理
		promise.error(function(data, status, headers, config){
		// 处理非成功的响应
		});

		调用http方法后，在下一个$digest循环运行之前它并不会被真正执行，如果想执行，需要在$apply内强制digest循环执行，我们的promise可以被resolve

		$http对象提供了一系方法支持方便调用。get/post/delete/config/head/json等。本身的构造方法，支持一系的参数设置，如 cache/url/header/params/transformResponse/timeout/withCredentials/responseType

	请求拦截:
		需求 ：如果服务器返回401状态码，我们会希望将用户重定向到登录页面。
		拦截器实际上是$http服务的基础中间件，用来向应用的业务流程中注入新的逻辑。它的核心是服务工厂，通过向$httpProvider.interceptors数组中添加服务工厂，在$httpProvider中进行注册。

		一共有四种拦截器，两种成功拦截器，两种失败拦截器，AngularJS通过$http设置对象来对请求拦截器进行调用。
			request ：它可以对设置对象进行修改，或者创建一个新的设置对象，它需要返回一个更新过的设置对象，或者一个可以返回新的			设置对象的promise。
			response:它可以对响应进行修改，或者创建一个新的响应，它需要返回一个更新过的响应，或者一个可以返回新响应的promise。
			requestError　：AngularJS会在上一个请求拦截器抛出错误，或者promise被reject时调用此拦截器
			responseError　：　AngularJS会在上一个响应拦截器抛出错误，或者promise被reject时调用此拦截器。

		angular.module('myApp', [])
		.factory('myInterceptor', function($q) {
			var interceptor = {
				'request': function(config) {
					// 成功的请求方法
					return config; // 或者 $q.when(config);
				},
				'response': function(response) {
					// 响应成功
					return response; // 或者 $q.when(config);
				},
				'requestError': function(rejection) {
					// 请求发生了错误，如果能从错误中恢复，可以返回一个新的请求或promise
					return response; // 或新的promise
					// 或者，可以通过返回一个rejection来阻止下一步
					// return $q.reject(rejection);
				},
				'responseError': function(rejection) {
					// 请求发生了错误，如果能从错误中恢复，可以返回一个新的响应或promise
					return rejection; // 或新的promise
					// 或者，可以通过返回一个rejection来阻止下一步
					// return $q.reject(rejection);
				}
			};
			return interceptor;
		});
		我们需要使用$httpProvider在.config()函数中注册拦截器：

		angular.module('myApp', [])
		.config(function($httpProvider) {

			$httpProvider.interceptors.push('myInterceptor');


			设置$httpProvider : 
				使用.config()可以向所有请求中添加特定的HTTP头，这非常有用，尤其是我们希望将身份
				验证的头同请求一同发送，或设置响应类型的时候。
				
				通过.config()函数可以对这些头进行修改或扩充

				默认的请求头保存在$httpProvider.defaults.headers.common对象中
		});

	$resource : 可选服务,适用于RESTful。
		我们可以用它非常方便地同支持RESTful的服务端数据源进行交互，当同支持RESTful的数据模型一起工作时，它就派上用场了。

		$resource服务可以将$http请求转换成save和update等简单形式。我们可以通过$resource服务来处理复杂的细节，而无需自己编写重复和繁琐的业务代码。

		$resource服务本身是一个创建资源对象的工厂。返回的$resource对象中包含了同后端服务器进行交互的高层API。
		var User = $resource('/api/users/:userId.json',
			{
				userId: '@id'
			}
		});

		$resource五个常用的方法:

		2个get 类型方法:区别是query期望返回的是数组。
			get(params, successFn, errorFn)

			// GET /api/users/123
			User.get({
				id : 123
			},function(resp) {
				// 处理响应成功
			}, function(err) {
				// 处理错误
			});


			query(params, successFn, errorFn)

			// GET /api/users
			User.query(function(users) {
				// 读取集合中第一个用户
				var user = users[0];
			});

		3个非get方法:
			save(params, payload, successFn, errorFn)

			// POST /api/users
			// with the body {name: 'Ari'}
			User.save({}, {
				name: 'Ari'
			}, function(response) {
				// 处理响应成功
			}, function(response) {
				// 处理非成功响应
			});

			delete(params, payload, successFn, errorFn)  区别于remove，delete是保留字
			// 发起一个请求：
			// DELETE /api/users
			User.delete({}, {
				id: '123'
			}, function(response) {
				// 处理成功的删除响应
			}, function(response) {
				// 处理非成功的删除响应
			});

			remove(params, payload, successFn, errorFn)

			// 发起一个请求：
			// DELETE /api/users
			User.remove({}, {
				id: '123'
			}, function(response) {
				// 处理成功的删除响应
			}, function(response) {
				// 处理非成功的删除响应
			});


			响应会被一个原型类所包装，并在实例上添加 $save()/$remove()/$delete()方法。除非在一个单独的资源上而不是一个集合上被调用，否则这三个方法与资源上对应的方法是一样的。

			// 使用实例方法$save()
			User.get({id: '123'}, function(user) {
				user.name = 'Ari';
				user.$save(); // Save the user
			});
			// This is equivalent to the collection-level
			// resource call
			User.save({id: '123'}, {name: 'Ari'});

			这三个方法在调用时$resource对象会立即返回一个空的数据引用。如果数据回来了，就修改了引用，后面使用的引用的地方就有值。如:
			// $scope.user将为空
			$scope.user = User.get({id: '123'});
			也可在回调里面操作:
			User.get({id: '123'}, function(user) {
				$scope.user = user;
			});

			$resource集合和实例有两个特殊的属性用来同底层的数据定义进行交互:
				$promise:是$resource生成的原始promise对象。这个属性是特别用来同$routeProvider.when()在resolve时进行连接的。
						如果请求成功了，资源实例或集合对象会随promise的resolve一起返回。如果请求失败了，pomise被resolve时会返回HTTP响应对象，其中没有resource属性。

				$resolved : $resolved属性在服务器首次响应时会被设置为true（无论请求是否成功）。

			扩展$resource方法:
			var User = $resource('/api/users/:userId.json', {
				userId: '@id'
				sendEmail: {
					method: 'POST'
				},
				allInboxes: {
					method: 'JSONP',
					isArray: true
				}
			});
			借助这个User资源，资源集合（User资源对象）中的个体实例现在可以使用sendEmail()和
			update()方法了（也就是user.$sendEmail()和user.$update()）。

	$resource 的设置对象和$http差不多。包括method/url/params/isArray/transformRequest/transformResponse
			这个函数或函数数组用来对HTTP请求的请求体和头信息进行转换，并返回转换后的版本。通常用来进行序列化。
			var User = $resource('/api/users/:id',{
				id: '@'
			}, {
				sendEmail: {
					method: 'PUT',
					transformRequest: function(data, headerFn) {
						// 返回修改后的请求数据
						return JSON.stringify(data);

						transformResponse时使用:
						return JSON.parse(data);
					}

			}
			});


	创建自定义服务给了我们对应用进行高度自定义的能力，可以对远程服务通信进行抽象，并且从控制器和视图中解耦出来。

	最后，我们强烈建议在自定义的服务对象内部使用$resource。这不仅可以将加载远程服务抽象成一个独立的AngularJS服务，同时将其从控制器中解耦，保证控制器的代码清洁。另外，还使得我们可以不必关心控制器是如何取得数据的。对测试也是有好处的。

	angular.module('myApp', ['ngResource'])
	.factory('UserService', [
		'$resource', function($resource) {
			return $resource('/api/users/:id', {
			id: '@'
			}, {
			update: {
				method: 'PUT'
			}
			});
	}]);


Restangular(扩展库,高度的可定制性,单例)：
	Restangular是一个专门用来从外部读取数据的AngularJS服务。

	两种方式创建拉取数据的对象:
		基础路由:
			var User = Restangular.all('users');
			所有的HTTP请求将/users路径作为根路径来拉取数据:
			var allUsers = User.getList(); // GET /users
		通过单个对象来发送嵌套的请求，可以用唯一的ID来代替路由发送请求：
			var oneUser = Restangular.one('users', 'abc123');

			oneUser上的get()时向/users/abc123发送请求
			oneUser.get().then(function(user) {

				// GET /users/abc123/inboxes
				user.getList('inboxes');
			});

		通过向allUrl方法传入一个独立的参数来指定请求的URL:
			// 搜索的所有URL都将使用
			// `http://google.com/`asthebaseUrl
			var searches = Restangular.allUrl('one', 'http://google.com/');
			// 将发送一个请求到GET http://google.com/
			searches.getList();

			也可以通过oneURL方法针对特定的请求，设置基础URL而不是操作整个请求：

				var singleSearch = Restangular.oneUrl('betaSearch', 'http://beta.google.com/1');
				// 触发一个请求到GET http://google.com/1
				singleSearch.get();

	使用:
		当Restangular将初始化的对象返回给我们后，可以通过几种不同的方法与后端API进行交互。

		假设我们创建了一个Restangular对象代表公共讨论列表：
		var messages = Restangular.all('messages');

		// 所有消息都是一个将被resolve成所有消息列表的promise
		var allMessages = messages.getList();

		// POST到/messages
		var newMessage = {
			body: 'Hello world'
		};
		messages.post(newMessage);
		// 或者我们将在一个元素上调用这个函数
		// 以创建嵌套的资源 !!!
		var message = Restangular.one('messages', 'abc123');
		message.post('replies', newMessage);

		Restangular返回的是增强过的promise对象，可以调用then,$object(用于异步引用，返回空后，用数据填充引用)等。

		// 然后在promise中调用
		messages.post(newMessage).then(function(newMsg){
			// 首先将消息设置成空数组
			// 然后一旦getList是完整的就填充它
			$scope.messages = messages.getList().$object;
		}, function(errorReason)
			// 出现了一个错误
		});

		从集合中移除
		var message = messages.get(123);
		message.remove(); // 发送DELETE HTTP请求

		put : 
			注意，在修改一个对象之前对其进行复制，然后对复制的对象进行修改和保存是一
			个好做法。Restangular有自己的复制版本，因此无需对一系列方法重新进行绑定。在更
			新对象时使用Restangular.copy()是一个比较好的实践。

	嵌套资源 : 嵌套资源是指包含在其他组件内部的组件。例如，一个特定作者所写过的所有书籍。
		var author = Restangular.one('authors', 'abc123');
		// 构建一个GET到/authors/abc123/books的请求
		var books = author.getList('books');

		Restangular中另外一个酷炫的功能是不仅可以在one和all方法创造的对象上调用post、put、
		getList等方法，也可以在服务器返回的对象上调用。例如，我们可以在代码中首先拉取一个作
		者并进行展示，然后获取他的书籍列表：
		Restangular.one('authors', 'abc123').then(function(author) {
			$scope.author = author;
		});

		// 然后在代码中将
		// 构建一个GET到/authors/abc123/authors的请求
		// 使用$scope.author，它是从服务器返回的真实对象
		$scope.author.getList('books');


		如果不是RESTful资源，可以自定义:
		// 映射一个GET到/users/abc123/biography的请求
		author.customGET("biography");
		// 或者带有一个新bio对象的POST
		// as {body: "Ari's bio"}
		// 中间的两空字段是
		// 参数字段或任意自定义头部
		author.customPOST({body: 'Ari\'s Bio'},// post body
		"biography", // 路由
		{}, // 自定义参数
		{}); // 自定义头部

设置Restangular : 
	如果设置Restangular时需要用到其他服务，那么就在run()方法中设置，否则就在config()中进行设置

	在实践中，只通过一个切入点（主URL）来同后端服务器进行通信是非常好的做法，其他数据模型通过链接来指向相关联的资源。
	Restangular通过selfLink、oneUrl和allUrl来支持这个有用的做法。


	angular.module('myApp', ['restangular'])
		.config(function(RestangularProvider) {
			RestangularProvider.setBaseUrl('/api/v1');

			// 3个参数：
			// route
			// 如果它是一个集合——布尔值（true/false）或者
			// 如果你需要这两个选项以及变换器
			// 则不发送
			RestangularProvider.addElementTransformer('authors', false, function(element) {
				element.fetchedAt = new Date();
				return element;
			});

			小提示：我们可以同时使用requestInterceptors和responseInterceptors来实现全页面
			范围内的加载提示。在每个请求之前开始加载提示，在收到请求后停止加载提示。

			RestangularProvider.setResponseInterceptor(function(data, operation, what) {
				if (operation == 'getList') {
				var list = data[what];
				list.metadata = data.metadata;
				return list;
				}
				return data;
			});

			RestangularProvider.setRequestInterceptor(function(elem, operation, what) {
				if (operation === 'put') {
				elem._id = undefined;
				return elem;
				}
				return elem;
			});

			RestangularProvider.setErrorInterceptor(function(resp) {
				将其捕获并将用户重定向到登录页面。
				displayError();
				return false; // 停止promise链
			});

			首先要设置selfLink字段。同设置ID非常类似，selfLink将路径设置为数据模型的一个属性，而数据模型通过链接同对应的资源相关联。这样我们可以知道应该将PUT或GET请求发送到哪个URL。

			angular.module('myApp', ['restangular'])
				.config(function(RestangularProvider) {
				RestangularProvider.setRestangularFields({
					selfLink: 'link.href'
				});
			});

			//$scope.authors = Restangular.all('authors').getList().$object;
			var firstAuthor = authors[0];
			firstAuthor.name="John";
			// PUT到/authors/1988-author-1
			// url在firstAuthor.link.href中
			firstAuthor.put();
			// GET到/books/for-author/1988-author-1
			var books = Restangular.allUrl('books', firstAuthor.books.href)
			.getList().$object;
		});

	自定义服务:
		angular.module('myApp', ['restangular'])
		.factory('MessageService', ['Restangular', function(Restangular) {
			var restAngular = Restangular.withConfig(function(Configurer) {
				Configurer.setBaseUrl('/api/v2/messages');
			});

			var _messageService = restAngular.all('messages');
	
			return {
				getMessages: function() {
					return _messageService.getList();
				}
			};
		}]);

	var rquest = 
	{
		get : function(){
			var result = {};

			setTimeout(function(){_.extend(result,{a : 1 ,click : function(obj,str){str = 'tt';obj.a = 'xxxx';console.log('----')}});},5000);

			return {$object : result}
		}
	}
	var c = rquest.get().$object;





XHR : ------------------------------------
		跨域通信、同源

		JSONP : 安全上有缺陷
			$http.jsonp("https://api.github.com?callback=JSON_CALLBACK") .success(function(data) {// 数据});
			类似于 : 
			<script src="https://api.github.com?callback=angular.callbacks._0" type="text/javascript"></script>
			response : // 简写
						angular.callbacks._0({
						'meta': {
						'X-RateLimit-Limit': '60',
						'status': 200
						},
						'data': {
						'current_user_url': 'https://api.github.com/user'
						}
						})

		CORS(W3C制定):
			使用 : 
				告诉AngularJS使用XDomain，并从所有的请求中把X-Request-With头移除掉。
				angular.module('myApp', [])
				.config(function($httpProvider) {
					$httpProvider.defaults.useXDomain = true;
					delete $httpProvider.defaults.headers.common['X-Requested-With'];
				});
			服务器支持  ： 响应中加入几个访问控制相关的头
				Access-Control-Allow-Origin ： 这个头的值可以是与请求头的值相呼应的值，也可以是*，
												从而允许接收从任何来源发来的请求
				Access-Control-Allow-Credentials（可选） 默认情况下，CORS请求不会发送cookie。如果返回这个头，就可以通过将
														withCredentials设置为true来将cookie同请求一同发送出去。
														如果将$http发送的请求中的withCredentials设置为true，但服务器没有返回Access-Control-Allow-Credentials，请求就会失败，反之亦然。

				后端服务器必须能处理OPTIONS方法的HTTP请求。
		CORS请求分为简单和非简单两种类型。
			简单请求:HEAD/GET/POST/Accept/Accept-Language /Content-Language/Last-Event-ID/Content-Type/application/x-www-form	      -urlencoded/multipart/form-data/text/plain。
			非简单请求:
						如果想要支持PUT或DELETE方法，又或者想给请求设置特殊的内容类型，就需要发送非简单请求
						尽管这些请求在客户端开发者看来没什么不同，但浏览器会以不同的方式处理它们
						浏览器实际上会发送两个请求：预请求和请求。浏览器首先会向服务器发送预请求来获得发送请求的许可，只有许可通过了，浏览器才会发送真正的请求。
						浏览器处理CORS的过程是透明的。同简单请求一样，浏览器会给预请求和请求都加上Origin头。
				预请求特点:
						预请求是OPTIONS类型
						Access-Control-Request-Method头：请求所使用的HTTP方法，会始终包含在请求中
						Access-Control-Request-Headers （可选) ：值是一个以逗号分隔的非简单头列表，列表中的每个头都在请求中，服务器检查头的合法性，并返回
						Access-Control-Allow-rigin这个头，值必须和请求的来源相同，或者是*符号，以允许接受来自任何来源的请求。
						Access-Control-Allow-Methods，表示可以接受的HTTP方法列表，并对缓存有好处，也可以不总是发送预请求。
						Access-Control-Allow-Headers,如果设置了这个头，server必须添加同一个头。
						预请求返回200后才发送真正的请求。
		服务器代理:通过服务器代替client发送请求。


	权限验证:
		1. 通过token令牌实现。每个请求不用每次携带cookie。通过拦截器对每个请求添加。
		2. 通过对url路由加入级别1,2,3,4，在.constant定义级别，通过在.run里面监听$routeChangeStar事件检查用户是否有级别权限。并定义一个auth服务。保存user，访问cookie。闭包return 一个对象，提供对内部值的访问判断及修改。

	MongoDB : 
			即使没有Server，一样可以直接同提供了RESTful接口的数据库进行通信。

			在这个例子中，我们使用MongoLab①，这是一个SAAS服务，提供了可管理的MongoDB实例。

			angular.module('myApp', ['restangular'])
			.constant('apiKey', 'API_KEY')//API访问key
			.config(function(RestangularProvider, apiKey) {

				//为了使用MongoLab，需要将baseUrl设置成API的切入点
				RestangularProvider.setBaseUrl('https://api.mongolab.com/api/1/databases/YOURDB/collections');

				//每个请求携带apiKey
				RestangularProvider.setDefaultRequestParams({
					apiKey: apiKey
				});

				//将MongoDB的_id.$oid字段映射到Restangular的id字段上
				RestangularProvider.setRestangularFields({
					id: '_id.$oid'
				});

				//最后需要覆盖_id字段，这个字段是MongoDB在更新记录时设置的。Mongo不允许覆盖_id字段，所以我们通过Restangular来模拟这个过程
				RestangularProvider.setRequestInterceptor(function(elem, operation, what) {
					if (operation === 'put') {
						elem._id = undefined;
						return elem;
					}
					return elem;
				});
			});


promise (被执行和拒绝): 
		promise是一种用异步方式处理值（或者非值）的方法，提供引用占位，看成远程对象代理。
		习惯上，JavaScript使用闭包或者回调来响应非同步的有意义的数据，比如页面加载之后的XHR请求。

		回调 : 使得调用不一致，得不到保证，当依赖于其他回调时，它们篡改代码的流程，通常会让调试变得非常难。

		在执行异步方法时触发一个函数，然后期待一个回调能运行起来。不同的是，promise是另外一种抽象：这些函数返回promise对象。
		promise让异步函数看上去像同步的。基于同步函数，我们可以按照预期来捕获返回值和异常值。获得功能组合和错误冒泡（error bubbling）能力的同时，保持代码异步运行的能力。
		此外，可以把promise串起来，并且允许代码以通常运行的方式来处理。从一个promise冒出的异常会贯穿整个promise链。
		promise总是异步执行的，可以放心使用，无需担心它们会阻塞应用的其他部分。

		promise是头等对象，自带了一些约定:
			只有一个resolve或者reject会被调用到：resolve被调用时，带有一个履行值；reject被调用时要带一个拒绝原因。
			如果promise被执行或者拒绝了，依赖于它们的处理程序仍然会被调用；
		 处理程序总是会被异步调用。

		// 示例回调代码 --> 这个回调金字塔已经失控了，而且我们还没有加入健壮的错误处理代码。此外，在被调用的
							回调内部，也需要知道参数的顺序。方法签名可不同。在回调里面处理一串逻辑。回调里面使用回调。
		User.get(fromId, {
			success: function(err, user) {
				if (err) return {error: err};
				user.friends.find(toId, function(err, friend) {
				if (err) return {error: err};
				user.sendMessage(friend, message, callback);
				});
			},
			failure: function(err) {
				return {error: err}
			}
		});

		// promise : -->  代码不仅仅是可读性变高了，也更容易理解了。我们可以保证回调是一个值，而不用处理回调接口。
						  方法签名相同。promise API就是用于明确地执行或者拒绝promise的。使用栈方法。依顺序执行。then处理的是一个值还不是一个回调函数，注意return。
		User.get(fromId)
		.then(function(user) {
				return user.friends.find(toId);
			}, function(err) {
				// 没找到用户
		})
		.then(function(friend) {
				return user.sendMessage(friend, message);
			}, function(err) {
				// 用户的朋友返回了异常
		})
		.then(function(success) {
				// user was sent the message
			}, function(err) {
				// 发生错误了
		});



		angular.module('myApp', [])
		.factory('GithubService', function($q, $http) {
		            // 从仓库获取事件
		            var getEventsFromRepo = function() {
		                // 任务
		                return 1;
		            }
		            var service = {
		                val : "x",
		                makeMultipleRequests: function(repos) {
		                    var d = $q.defer(),
		                    percentComplete = 0,
		                    output = [];
		                    
		                    for(var i in d)
		                    {
		                        output.push(i);
		                    }
		                    for (var i = 0; i < repos; i++) {
		                        output.push(i);
		                        //d.reject('no')
		                        //d.notify()
		                    }
		                    d.resolve(output);
		                    return d.promise;
		                }
		        }
		    return service;
		});

		function Ctrl($scope,GithubService) {
		    $scope.test = "xxxxxxxxxx";
		    GithubService.makeMultipleRequests(2)
		    .then(function(a){
		    		//success as resolve()
			    	alert('a' + a);
		    	},function(b){
		    		//error as reject()
		    		alert('b' + b);
		    	},function(c){
		    		//process as notify
		        	alert(c);
		    });
		    
		}


		可以使用两个种方式和promise交互 ：
		１. then(successFn, errFn, notifyFn) ： 无论promise成功还是失败了，当结果可用之后，then都会立刻异步调用successFn或者
												errFn : 传入结果或拒绝理由。notifyFn在执行前或拒绝前执行0到多次。

		2 . catch(errFn) : 帮助函数，能让我们用.catch(function(reason){})取代err回调：

		3 . finally(callback) : 观察promise的履行或者拒绝，而无需修改结果的值。当我们需要释放一个资源，或者是运行一些清理工作						，不管promise是成功还是失败时，这个方法会很有用。! : 保留字，通过 promise['finally']使用。

		Angular的$q deferred对象是可以串成链的，这样即使是then，返回的也是一个promise。这个promise一被执行，then返回的promise就已经是resolved或者rejected的了。可在then里面返回promise，串起来。promise是$http支持拦截器的原因。


	串联promise ,创建链式请求 :
		1 . then方法在初始promise被执行之后,返回一个新的派生promise(then里面返回一个new promise)。相当于将另一个then接在初始的then方式的后面。也就串起来了。

		// 一个响应promise的服务GithubService，返回提一个promise。
		GithubService.then(function(data) {
			var events = [];
			for (var i = 0; i < data.length; i++) {
				events.push(data[i].events);
			}
			return events;
		}).then(function(events) {
			$scope.events = events;
		});
		
	$q : 
		all (promises)	: 合并多个promise，all()方法返回单个promise，会执行一个数组或者一个散列的值。每个值会响应promise散列
							中的相同序号或者键。如果任意一个promise被拒绝了，结果的promise也会被拒绝。
		defer()         : 方法创建了一个deferred对象，它没有参数，返回deferred对象的一个实例。

		reject(reason) : 这个方法创建了一个promise，被以某一原因拒绝执行了。它专门用于让我们能在一个promise
						 链中转发拒绝的promise，类似JavaScript中的throw.
		when() 			: when()函数把一个可能是值或者能接着then的promise包装成一个$q promise。这样我们就能
						  处理一个可能是也可能不是promise的对象。


事件 : 事件在指令的隔离作用域里无法广播，因为事件是基于作用域链的。
	
	在应用程序内可以通过监听$scope对象的方式附加函数给这些事件。以下所有事件都会触发
	在$ootScope上，因此可以在任意$scope对象上监听这些事件。

	如何传播 :
		通过作用域链传播。有子父作用域。

	监听 ：通过$on注册监听事件，将其绑定在scope上面。

	事件对象属性:
		targetScope : 发送或者广播事件的作用域
		currentScope : 当前处理事件的作用域
		name : --
		stopPropagation() : 函数取消通过$emit触发的事件的进一步传播
        preventDefault() ：preventDefault把defaultPrevented标志设置为true。尽管不能停止事件的传播，我们可
							以告诉子作用域无需处理这个事件
	angular的核心事件:

	$emitted （向上广播到RootScope : 能被取消传播,建议不要大量向上传播事件）:
			$includeContentLoaded : 当ngInclude的内容重新加载时，从ngInclude指令上触发
			
			$includeContentRequested : 从调用ngInclude的作用域上发送。每次ngInclude的内容被请求时，它都会被发送

			$viewContentLoaded : 每当ngView内容被重新加载时，从当前ngView作用域上发送

	$broadcase （向下广播到子Scope : 不能被取消，可以通过属性，让子scope忽略。） : 
			$locationChangeStart : 当Angular从$location服务对浏览器的地址作更新时，会触发
			
			$locationChangeSuccess : 当且仅当浏览器的地址成功变更，又没有阻止$locationChangeStart事件的情况下，
									 $locationChangeSuccess事件会从$rootScope上广播出来。
			
			$routeChangeStart : 在路由变更发生之前，从$rootScope发送出来。也就是在路由服务开始解析路由变更所需的所有依赖项时					这个过程通常涉及获取视图模板和解析route属性上所有依赖项的时候。
			
			$routeChangeSuccess : 在所有路由依赖项跟着$routeChangeStart 被解析之后， 从$rootScope上广播出来。
									ngView指令使用$routeChangeSuccess事件来获悉何时实例化控制器并渲染视图。
			
			$routeChangeError : 如果路由对象上任意的resolve属性被拒绝了，$routeChangeError就会被触发（比如它们失
								败了）。这个事件是从$rootScope上广播出来的。
			$routeUpdate : 如果$routeProvider上的reloadOnSearch属性被设置成false，并且使用了控制器的同一个
							实例，$routeUpdate事件会被从$rootScope上广播。 
			$destroy : 在作用域被销毁之前，$destroy事件会在作用域上广播。这个顺序给子作用域一个机会，在
						父作用域被真正移除之前清理自身。比如清理timeout。


架构 :
	目录结构 : 略
	模块化: 	1 . 函数模块化 : 根据功能将应用程序分解为模块。当根据功能分解应用程序时，
				我们打算聚焦于模块函数（功能函数）而不是包含的函数类型（一类函数类型）。

				angular.module('app', [
					'app.home',
					'app:login'
				]);

				好处: 
					我们可以在逻辑中分解函数的类型
					你可以集中于为应用程序的每个组成部分提供一个个功能
					还可以为我们编写的部分编写测试，从而分解测试
					还可以延迟加载应用程序的不同部分，因此可以为屏幕中最常见的界面提供最快的应用程序体验
					一次编写模块就可跨应用程序共享它们，代码copy。

				2. 功能的模块化 : 按照模块功能（一类）划分，需要把这些模块注入为主应用的依赖项
				angular.module('myApp.directives', []);
				angular.module('myApp.services', []);
				angular.module('myApp.filters', []);
				// 我们经常在控制器中使用服务，
				// 所以，我们会把它们
				// 注入到'myApp.controllers'模块中
				angular.module('myApp.controllers', [
				'myApp.services'
				]);
				angular.module('myApp', [
				'myApp.directives',
				'myApp.controllers',
				'myApp.filters',
				'myApp.services'
				]);

	控制器: 
		可以移出处理DOM的方法，以减少控制器大小。把功能移动到自定义指令中，大幅降低了为判断是否公开特定视图或者格式化一个值的需要。
		
		因为我们在视图里绑定了$scope上的值，控制器没有必要负责持有DOM对象所需的状态

		指令并不一定要有视图模板。通常情况下，它们可以只作为视图之下处理数据的垫片。
		ngModelController控制器就是这种功能派上用场的一个例子。


angular 动画：
	创建动画 :
			使用CSS3动画；
			使用JavaScript动画；
			使用CSS3过渡。

	$animate服务支持多个Angular内置的指令，它们无需额外的配置即可支持动画



angular : 
		浏览器会在构建DOM元素时加载AngularJS库。也就是引用angular.js时。
		当浏览器触发DOMContentLoaded事件(html文档加载完成并开始解析时触发)时，angular开始工作，
		查找ng-app或用js启动。document.readyState为complete时
		也会初始化。如果没有ng-app，就认为是手动bootstrap()启动。
		手动场景:想要在某个其他库的代码运行之后，或者在运行时动态创建元素时，启动AngularJS应用。
				var newElement = document.createElement("div");
				angular.bootstrap(newElement, ['myApp']);//只能启动应用一次
		Angular会使用ng-app指令的值配置$injector服务
		一旦应用程序加载完成，$injector就会在应用程序的$rootScope旁边创建$compile服务。
		$rootScope创建后，$compile服务就会接管它。它会将$rootScope与现有的DOM连接起来，
		然后从将ng-app指令设置为祖先的地方开始编译DOM。
		$injector ----创建---> $compile ---接管----> $rootScope ---将rootScope连接到---> Dom ---> 从ng-app开始编译

		View : bower获取html时，后构建dom树并渲染显示。当获取到angular.js时，会stop解析dom。等待脚本返回并被执行。
				这里angular.js会设置DOMContentLoaded事件监听。在触发这个事件后，angular就开始介入，也就是在解析前介入，
				创建运行必要组件。然后就开始解析dom树。

				编译: $compile遍历dom树，查找指令，将指令的连接函数合并成一个单一的连接函数，如果有一个dom多个指令，就根据优先级来，然后用$injector服务查找和收集指令的compile函数，这个函数会在适当时处理dom转换或内联模板，如创建模板副本。每个节点的编码方法运行后，$compile会调用连接函数，link函数为封闭scope的指令设置监控。为创建实时视图。$comple完成后angular就运行时就准备好了。
				运行时: 一般bower，事件循环会waiting事件执行。当发现事件时，会将事件放到队列中。循环注册的事件队列。如果函数处理程序对事件作出响应，就会将event对象传给处理函数。angular会使用digest循环处理angular事件。digest循环包括两个循环：$evelAsync和$watch；分别对应两个队列片。

				事件会在angular的上下文被调用 。angular在rootscope上面触发digest并传播到子作用域。digetst循环会wait $evelAsync清空。并在当前上下文里面执行回调。这个$evalAsync用于在浏览器进行渲染之前，调度需要运行在当前桢栈（stack frame）之外的所有任务。然后脏检查，渲染dom。


angularRouter : 
		
		ui-view

		.config(function($stateProvider,$urlRouterProvider) {
			$stateProvider.state('start', 状态
				嵌套路由:
					ui-view下的ui-view
					start.xxxxx
			{
				url: '/start',可以给应用程序的状态分配一个唯一的URL，通过状态导航应用
					!:如果用户导航到/start，应用状态切换到start，然后用template填充ui-view
					param : /start:id = /start/{id} = /start/123456
							id = 123456
							$stateParams : {id : 123456}
					匹配规则://不能在路由内使用匹配
							// 只匹配包含6个十六进制数字的inbox ID
							url: '/inbox/{inboxId: [0-9a-fA-f]{6}}',
							// 或者匹配每个URL中`/inbox`后面的`inboxId`（全部捕获）
							url: '/inbox/{inboxId:.*} '
							// 匹配诸如/inbox?sort=ascending形式的路由
							url: '/inbox?sort'


				template : html = string or function
				templateUrl: url = string or function
				templateProvider : return html function
				resolve : { //在dom解析之后，渲染之前执行promise
							//
					// 当结果不是promise时立即返回
					person: function() {
						
					},
					// 这个函数返回一个promise，它会在控制器实例化之前解析
					currentDetails: function($http) {
						return $http ...
					},
					// 还可以在另一个解析中使用上面返回的promise
					facebookId: function($http, currentDetails) {
						$http({
							method: 'GET',
							url: 'http://facebook.com/api/current_user',
							params: {
							email: currentDetails.data.emails[0]
							}
						});
					}
				}
				controller : function($scope,person,currentDetails,facebookId){
					//string or function :如果没有template，就不会创建。
				}

				view : { //在一个状态内设置多个命名视图，忽略templateUrl、template和templateProvider
					模板的抽象状态（另一个状态）:
					/*
						<div>
							<div ui-view="filters"></div>
							<div ui-view="mailbox"></div>
							<div ui-view="priority"></div>
						</div>
					*/

					'filters': {
						template: '<h4>Filter inbox</h4>',
						controller: function($scope) {}
						resolve: {
							facebook: function() {
							return FB.messages();
						}
					},
					'mailbox': {...},
					'priority': {...}
				}
				abstract : true //抽象模板永远不能直接激活，但是可以设置被激活的子节点。
								//你可以使用抽象模板提供一个模板包装器来包裹多个命名视图，类似于上面的view属性。
								//或者传递$scope对象给子节点。你还可以使用它们来传递解析后的依赖或者自定义数据，
								//或者在同一url下嵌套多个路由（比如，所有的路由都在/admin URL之下）。
							$stateProvider
								.state('admin', {
									abstract: true,
									url: '/admin',
									template: ;<div ui-view></div>'
								})
								.state('admin.index', {
									url: '/index',
									template: '<h3>Admin index</h3>'
								})
								.state('admin.users', {
									url: '/users',
									template: '<ul>...</ul>'
								});
				onEnter : function
				onExit : function
				data : 附加任意数据给你的状态配置对象configObject.
						和resolve很像，但它不会注入后台ctrl,primse不会被解析。从父状态给子状态传递数据时使用。
			})
		});

国际化:前台指令国际化。
$cacheFacotory : key-value映射。
安全性 : $ace服务进行严格的上下文转义。
$scope中的值是经过$ace.getTrusted()返回的值。
指令也使用$ace.parseAs()替换$parse服务监控属性绑定，parseAs()方法使用调用 $ace.getTrusted()方法。
ng-bind-html指令调用$ace.parseAsHtml()过滤返回给界面，ng-include指令及templateUrl都会调用这个方法返回dom。
可以通过模块的config函数在$aceDelegateProvider服务上设置url的白名单及黑名单匹配规则。
$ace API : 
	getTrusted(type,maybeTrusted) : 返回可信任的值。
		等价方法：
			getTrustedCss(value) 		 = getTrusted($sce.CSS, value)
			getTrustedHtml(value) 		 = getTrusted($sce.HTML, value)
			getTrustedJs(value) 		 = getTrusted($sce.JS, value)
			getTrustedResourceUrl(value) = getTrusted($sce.RESOURCE_URL, value)
			getTrustedUrl(value) 		 = getTrusted($sce.URL, value)

	parse(type,expr) return function(context-求值环境, locals-局部变量，在context中重写值时非常有用){} :
				类似于$pase服务。parse将表达式转换为函数。
			parseAsCss(expr) 		= parseAs($sce.CSS, expr)
			parseAsHtml(expr) 		= parseAs($sce.HTML, expr)
			parseAsJs(expr)			= parseAs($sce.JS, expr)
			parseAsResourceUrl(expr)= parseAs($sce.RESOURCE_URL, expr)
			parseAsUrl(expr) 		= parseAs($sce.URL, expr)

	trustAs(type,string)返回一个信任对象，
			trustAsHtml(value) 			= trustAs($sce.HTML, value)
			trustAsJs(value) 			= trustAs($sce.JS, value)
			parseAsResourceUrl(value) 	= trustAs($sce.RESOURCE_URL, value)
			trustAsUrl(value) 			= trustAs($sce.URL, value)

	isEnabled() return boolean : 是否启用/禁用ace
		config : 
				// 关闭SCE
				$sceProvider.enable(false);


Angular性能优化:
	$digest循环:
			限制不没必要的监控数量 <= 2000
			防止多次(循环、1秒内多次)运行$digest。使用节流解决。
			在改动$scope时，不要在$rootScope上使用$scope.$apply()，
				这样会导致每个子scope 	进入digest循环。直接调用$scope.$apply()。

	$watch : 
			会在每个digest中被调用 ，已是减少功能、循环、逻辑。
			注意使用第三个参数。会导致保存对象副本
			使用它们跟踪明显会影响视图的变量。对于不会影响视图的任何事物都不需要使用$watch函数。
			移除监听器 ：很多时候视图只是将第一次最新数据显示，后面就不需要了。这时可以移除$watch。

			--ng-bind {{}}使用的显示都会注册一个watch
			//angular.element($("#info td:eq(1)")).scope().isLicenseOpt = true;可以使用这个查看。


			bindonce 模块: 即插即用模块，它只保留了监控一次的指令；它还为我们提供了传递异步数据的能力。非永久监控器。
			使用bindonce指令时创建的独立的临时监控器会在数据变得可用时被移除。如果数据在作用域中已经可用了，
			它不会创建监控器，而是渲染子元素

			最新版的Angular在找到恒定值时（比如，表达式解析为布尔值或者静态的整数）会自动移除$watch函数。

	ng-repeat : 
			这个指令是延迟资源最大之一，每个独立元素都有一个数据绑定。angular会为ng指令创建一个$watch
			<ul>
				<li ng-repeat="email in emails"> email : 每个email都有一个独立的监控函数。
					<a ng-href="#/from/{{ email.sender }}">
						{{ email.sender }}
					</a>
					<a ng-href="#/email/{{ email.id }}">
						{{ email.subject }}
					</a>
				</li>
			</ul>

			angular会为ng指令创建一个$watch。上面列表中有4 + 1个监控，100个元素，有500个$watch运行。

	filter : 视图中的filter会至少被调用2次，需要保持函数轻量快速。尽量不在视图中使用filter。
			 对某个不变集合进行过滤显示。我们可以缓存分类过的、筛选过的结果，只在必要时执行排序，
			 而不是在每个$digest循环中调用这些过滤器。这个变量缓存叫做记忆缓存。可以使用记忆缓存_.memoize。

	界面加载优化 : 
		压缩 : 使用uglify，通过Grunt使用它。
		利用$templateCache : 
			使用XHR加载模板可能会导致Web应用缓慢或者有卡顿的感觉。可以通过将模板包装为JavaScript文件，
			然后连同应用程序的其他部分一起传输的方式伪造模板缓存加载，而不是通过XHR提取模板。可以通过grunt-angulartemplates工具使用。


Debug : 
	Dom : 
		angular.element($0).inheritedData()
		angular.element($("#trapIPAddressTable")).controller()
		angular.element($("#trapIPAddressTable")).scope()
		angular.element($("#trapIPAddressTable")).scope().$$watchers
		angular.element('html').injector().get("message")
	js debugger

	Angular Batarang : 
























function Scope() {
  this.$$watchers = [];
  this.$$asyncQueue = [];//类似于timeout的延时执行代码的队列，放在$digest里面，循环出来调用，不在监听里面，在$digest的循环里。如在监听里面加了这个，保证在监听后面执行。在现有的$digest的循环里执行。表示很快执行。
  this.$$phase = null;
}

Scope.prototype.$watch = function(watchFn, listenerFn, valueEq) {
  var watcher = {
    watchFn: watchFn,
    listenerFn: listenerFn,//这个函数会在初始化时调用一次，oldval和newval都是undefined。
    valueEq: !!valueEq //用于比较对象内部及数组内部值是否变化。
  };
  this.$$watchers.push(watcher);
};

Scope.prototype.$$areEqual = function(newValue, oldValue, valueEq) {
  if (valueEq) {
    return _.isEqual(newValue, oldValue); //引用没有变化。但内部值变化。
  } else {
    return newValue === oldValue ||   //引用变化
      (typeof newValue === 'number' && typeof oldValue === 'number' &&
       isNaN(newValue) && isNaN(oldValue));  // NaN not a number : NaN != NaN
  }
};

Scope.prototype.$$digestOnce = function() {
  var self  = this;
  var dirty;
  _.forEach(this.$$watchers, function(watch) {//遍历完整个$watch列表，只要有任何值发生变化，
  											  //应用将会退回到$watch循环中，直到检测到不再有任何变化。
    try {
      var newValue = watch.watchFn(self);
      var oldValue = watch.last;
      if (!self.$$areEqual(newValue, oldValue, watch.valueEq)) {
        watch.listenerFn(newValue, oldValue, self);
        dirty = true;
      }
	    watch.last = (watch.valueEq ? _.cloneDeep(newValue) : newValue); //深拷贝对象，用于比较内部值。
    } catch (e) {
      (console.error || console.log)(e); //异常处理
    }
  });
  return dirty;
};

Scope.prototype.$digest = function() {
	this.$beginPhase("$digest");//标记阶段
  var ttl = 10;//防止死循环(如果两个监听器互相监控了对方产生的变更) 
  			   //: 可接受的迭代数量内。如果这么多次之后，作用域还在变更，就勇敢放手，宣布它永远不会稳定。
  var dirty;
  do {
    dirty = this.$$digestOnce();
    if (dirty && !(ttl--)) {
      throw "10 digest iterations reached";
    }
  } while (dirty);

  this.$clearPhase();//清除阶段


  ....//可以处理在digest后运行的代码。同样使用队列注册方式，在此处循环。
};


$eval - 在作用域的上下文上执行代码,专门与作用域的内容打交道的，$eval让这一切更加明显 : 
	Scope.prototype.$eval = function(expr, locals) {
	  return expr(this, locals);//this:在调用的上下文中执行。
	};

$apply - 集成外部代码与digest循环: 
	我们可以执行一些与Angular无关的代码，这些代码也还是可以改变作用域上的东西，$apply可以保证作用域上的监听器可以检测这些变更。
	当人们谈论使用$apply集成代码到“Angular生命周期”的时候，他们指的就是这个事情。
	Scope.prototype.$apply = function(expr) { 
	  try {
	  	this.$beginPhase("$apply");//标记阶段
	    return this.$eval(expr); //用$eval执行这个函数的参数。
	  } finally {
	  	this.$clearPhase();//清除阶段设置
	    this.$digest();  //最终执行。
	  }
	};

作用域阶段(phase) : 作用域上一个简单的字符串属性，存储了现在正在做的信息

	//设置阶段，设置正在做的事情
	Scope.prototype.$beginPhase = function(phase) {
	  if (this.$$phase) {
	    throw this.$$phase + ' already in progress.';
	  }
	  this.$$phase = phase;
	};

	//设置阶段，清除正在做的事情
	Scope.prototype.$clearPhase = function() {
	  this.$$phase = null;
	};


!!! : 写法: 注册一个东西，返回一个闭包，可以对其操作，如$watch有返回值的。
	Scope.prototype.$watch = function(watchFn, listenerFn, valueEq) {
	  var self = this;
	  var watcher = {
	    watchFn: watchFn,
	    listenerFn: listenerFn,
	    valueEq: !!valueEq
	  };
	  self.$$watchers.push(watcher);
	  return function() {
	    var index = self.$$watchers.indexOf(watcher);
	    if (index >= 0) {
	      self.$$watchers.splice(index, 1);
	    }
	  };
	};

!!! : 注意Scope整个结构，通过构造初始化对象，在原型上加方法，让每个实例继承。
!!! : $watch是监听。
$watchCollection(obj,listener) : 用于集合和对象属性变更。相当于$wathc的第三个参数。
$beginPhase : 标记当前处理阶段 ，如果有正在处理的阶段，就报错，也就是$apply()调用报错。
$clearPhase : 清除上面标记
$apply : 用于将非angular代码加入angular生命周期。使用$eval和Scope交互执行参数函数。最后调用digest处理监听。
$eval : 和scope交互。将当前作用域当作参数传给执行代码。可以传给$eval字符串表达式，它会编译在作用域的上下文中执行。
$digest : 脏检查。引用检查、对象属性检查、循环检查。
		  由$watch和$apply组成。

$evalAsync : 一种在当前作用域上调度表达式在未来某个时刻运行的方式。并在$digest循环中调用使用$evalAsync
			注册的一个$$asyncQueue的队列。
			
			无论何时，在Angular中，只要你想要在一个行为的执行上下文外部执行另一个行为，
			就应该使用$evalAsync()函数

			$digest循环期间，贯穿脏值检查生命周期的每个循环之间的队列都是空的，这意味着使用
			$evalAsync来调用任何函数都会发生两件事情: //就是$evalAsync是在外层循环，不在脏检查里面。并$evalAsync执行了就删除
				函数会在这个方法被调用的某个时刻之后执行。//在digest里面执行。不在脏检查里面执行
				表达式求值之后至少会执行一次$digest循环。//是由于把对$digest的调度放进$evalAsync，
														 //检查现有阶段及没有异步执行任务，就run $digest()

			细节:

				如果指令直接调用$evalAsync()，它会在Angular操作DOM之后、浏览器渲染之前运行。
			 	
				如果控制器调用$evalAsync()，它也会在Angular操作DOM之后、浏览器渲染之前运行
				（永远不要使用$evalAsync()来约定事件的顺序）。

			可用setTimetout替代。但这是在渲染之后执行。屏幕会闪烁。


界面上的{{}}表达式。通过注册一个$watch。保证实时更新。
!!! : $scope对象上的属性只会在其被用于视图时绑定：记住，对于所有绑定给同一$scope对象的UI元素，
		只会添加一个$watch到$watch列表中。这些$watch列表会在$digest循环中通过一个叫做“脏值检查”的程序解析。

例:
	<h2>Sign in</h2>
	<input type="text" placeholder="Your name" ng-model="name" ng-minlength="3" />
	<input type="submit" ng-click="login()" value="Login" />

	这里通过ng-model指令在视图中绑定了一个name，Angular会设置一个隐式的监控器，将这
	个输入字段的值绑定为当前的$scope对象。

	当用户输入一个字符到表单中时，Angular上下文就会生效并开始遍历$$watchers（$watch
	列表）。
	在这个例子中，$watch列表只包含了一个唯一的元素：$scope.name。由于用户通过输入一
	个字符改变了输入字段的值，这个监控函数就会在$scope.name绑定上执行。在我们退出$digest
	循环之前，这一行为会触发在该值（由ng-model绑定）上运行的验证和格式化操作。
	由于在digest循环中值发生了变化，Angular需要再次运行这一循环以确定它没有改变作用域
	对象上的其他值。
	为什么要再次运行digest循环？如果有一个名为$scope.full_name的属性由
	$scope.first_name + $scope.last_name组成，那么这些值的任何变化都会改
	变$scope.full_name，因此循环需要再次执行以确认不再有任何变化了。也可能是在listener函数中改变了
	$scope中的其它值。
	因为这里只改变了$scope.name属性，并没有改变$scope对象中的其他任何属性，所以
	$digest循环会退出，然后浏览器会重绘DOM以刷新视图。
	当用户在输入字段中输入他们的名字并点击提交按钮时，会引发一个略有不同的流程。
	ng-click为DOM元素绑定了浏览器原生的click事件。当这个DOM元素收到点击事件时，
	ng-click指令会调用$scope.$apply()，同时进入$digest循环。

$digest的脏检查 （Object.observe）: 
	$digest会循环所有被$watch()注册的监听器。
	检查值是否发生了变化，而整个应用还没同步该变化。
	游戏引擎、数据库引擎以及对象关系映射程序（ORMs）都是这类系统很好的例子

界面上输入eamil 检查流程:

$digest循环--> old_val = "" : new_val = "123@qq.com" : dirty = true -->重新$digest循环
old_val = "123@qq.com" : new_val = "123@qq.com" : dirty = false -->结束$digest循环 --> dom重绘
